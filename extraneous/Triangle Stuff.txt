
    Point lightIn(const Point P, const Vec wi) const;

    Point lightOut(prims::Triangle &sx, const Vec &wo, const Point &X) const;

    bool findFirstIntersection(const Point &P, const Vec &w, prims::Triangle &s, float &t) const;

    bool rayTriangleIntersect(const Point &P, const Vec w, const Point V[3], float b[3], float &t) const;

    bool testAllTriangles(const Point P, const Vec w, prims::Triangle &tri, float &t) const;

    bool visible(const Point X, const Point Y) const;










// checks for intersection between triangle and ray.
// P + tw is ray, and V[3] is triangle. Stores barycentric coordinates in b[],
// and stores the intersection distance in t. Otherwise returns false.
bool Scene::rayTriangleIntersect(const Point &P, const Vec w, const Point V[3], float b[3], float &t) const
{
    const float precision = 1e-6;

    // Edge vectors
    const Vec &edge1 = math::sub(V[1].direction(), V[0].direction());
    const Vec &edge2 = math::sub(V[2].direction(), V[0].direction());

    // Normal
    const Vec &n = math::crossProduct(edge1, edge2);

    const Vec &q = math::crossProduct(w, edge2);
    const float a = math::dotProduct(edge1, q); // this is prob the m

    // Return false if nearly parallel or backfacing, or close to precision limit
    if ((math::dotProduct(n, w) >= 0) || (abs(a) <= precision))
        return false;

    const Vec &s = math::scale(1 / a, math::sub(P, V[0]).direction());
    const Vec &r = math::crossProduct(s, edge1);

    b[0] = math::dotProduct(s, q); // Barycentric coordinates of V0
    b[1] = math::dotProduct(r, w); // Barycentric coordinates of V1
    b[2] = 1.0f - b[0] - b[1];     // Barycentric coordinates of V2

    // Intersection outside triangle
    if ((b[0] < 0.0f || b[1] < 0.0f || b[2] < 0.0f))
        return false;

    t = math::dotProduct(edge2, r);
    return (t >= 0.0f);
}

// Returns if the ray has intersected a triangle or not and stores the closest triangle
bool Scene::testAllTriangles(const Point P, const Vec w, prims::Triangle &tri, float &t) const
{
    float min = t = std::numeric_limits<float>::max();
    for (int i = 0; i < tlist.size(); i++)
    {
        const prims::Triangle temp = tlist.triangle(i);
        float b[3];
        rayTriangleIntersect(P, w, temp.m_vertex, b, t);
        if (t < min)
        {
            min = t;
            tri = temp;
        }
        return (min != std::numeric_limits<float>::max());
    }
}

// Takes in a light point Y and a test point X and checks if there are any triangles intersecting it
bool Scene::visible(const Point Y, const Point X) const
{
    Vec b = math::sub(Y, X).direction();
    Vec a = math::getUnitVec(b);
    // const Vec b = Vec(0.02, 0.02, 0.02);
    // const Vec w = math::add(a, b); // Add bump
    prims::Triangle tri;
    float t;
    if (findFirstIntersection(Y, a, tri, t))
    {
        return true;
    }
    return false;
}

// Returns the amount of light received if the ray intersects wtih a triangle. Otherwise returns 0.
Point Scene::lightIn(const Point P, const Vec wi) const
{
    // Intersection triangle
    prims::Triangle s;
    // Intersection distance
    float t;
    if (findFirstIntersection(P, wi, s, t))
    {
        Point intsec = math::add(P, math::point((math::scale(t, wi))));
        // std::cout << "found intersection at: " << intsec.x << intsec.y << intsec.z << std::endl;
        Point L;
        L = lightOut(s, -wi, intsec);
        return L;
    }
    return Point(0, 0, 0); // No intersection has been found
}

// Returns the amount of light that bounces from a surface (not using a surfel)
Point Scene::lightOut(prims::Triangle &sx, const Vec &wo, const Point &X) const
{
    // Local radiance, we'll implement that later
    Point L = sx.material.emittedRadiance(wo);
    // Position of the intersection point
    // The dot product(?) between the light source and the normal of the material (in world coordinates)
    const Vec &edge1 = math::sub(sx.m_vertex[1].direction(), sx.m_vertex[0].direction());
    const Vec &edge2 = math::sub(sx.m_vertex[2].direction(), sx.m_vertex[0].direction());
    const Vec &n = math::crossProduct(edge1, edge2);

    for (const prims::Light &light : lights)
    {
        const Point &Y = light.getPosition();

        if (visible(Y, X))
        {
            const Vec &wi = math::sub(Y, X).direction();
            const Point &bi = light.biradiance(X);
            const Point &f = sx.material.finiteScatteringDensity(wi, wo);
            L = L + math::scale(abs(math::dotProduct(n, wi)), bi * f);
        }
    }

    return L;
}

// Finds the first intersection of a triangle and stores the triangle in s, and returns true. Returns false if nothing is intersected by the ray.
bool Scene::findFirstIntersection(const Point &P, const Vec &w, prims::Triangle &s, float &t) const
{
    prims::Triangle tri;
    if (testAllTriangles(P, w, tri, t))
    {
        s = tri;
        return true;
    }
    else
        return false;
}

// This takes too long to add. Need a better way to add primitive shapes / organize triangles. Also things are clockwise for some reason
void Scene::debugAddCube()
{
    tlist.addTriangle(prims::Triangle(Point(2, 0, -20),
                                      Point(-1, 0, -20),
                                      Point(-1, 3, -20)));
    tlist.addTriangle(prims::Triangle(Point(2, 0, -20),
                                      Point(-1, 3, -20),
                                      Point(2, 3, -20)));
    tlist.addTriangle(prims::Triangle(Point(2, 0, -23),
                                      Point(2, 0, -20),
                                      Point(2, 3, -20)));
    tlist.addTriangle(prims::Triangle(Point(2, 0, -23),
                                      Point(2, 0, -20),
                                      Point(2, 3, -20)));
    tlist.addTriangle(prims::Triangle(Point(),
                                      Point(),
                                      Point()));
    tlist.addTriangle(prims::Triangle(Point(),
                                      Point(),
                                      Point()));
    tlist.addTriangle(prims::Triangle(Point(),
                                      Point(),
                                      Point()));
    tlist.addTriangle(prims::Triangle(Point(),
                                      Point(),
                                      Point()));
    tlist.addTriangle(prims::Triangle(Point(),
                                      Point(),
                                      Point()));
    tlist.addTriangle(prims::Triangle(Point(),
                                      Point(),
                                      Point()));
    tlist.addTriangle(prims::Triangle(Point(),
                                      Point(),
                                      Point()));
    tlist.addTriangle(prims::Triangle(Point(),
                                      Point(),
                                      Point()));

    std::cout << tlist.size() << std::endl;
    ;
}